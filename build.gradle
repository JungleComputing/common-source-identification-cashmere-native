plugins {
    id 'java-library'
    id 'maven-publish'
    id 'com.jfrog.bintray' version '1.8.0'
}


version = '1.2'

def pomConfig = {
    scm {
        url "https://github.com/JungleComputing/common-source-identification-cashmere-native.git"
    }
}

task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

artifacts {
    archives sourcesJar
}

def static getOsString() {
    String vendor = System.getProperty("java.vendor");
    if ("The Android Project" == vendor) {
        return "android";
    } else {
        String osName = System.getProperty("os.name");
        osName = osName.toLowerCase(Locale.ENGLISH);
        if (osName.startsWith("windows")) {
            return "windows";
        } else if (osName.startsWith("mac os")) {
            return "apple";
        } else if (osName.startsWith("linux")) {
            return "linux";
        } else if (osName.startsWith("sun")) {
            return "sun"
        }
        return "unknown"
    }
}

def static getArchString() {
    String osArch = System.getProperty("os.arch");
    osArch = osArch.toLowerCase(Locale.ENGLISH);
    if ("i386" == osArch || "x86" == osArch || "i686" == osArch) {
        return "x86";
    } else if (osArch.startsWith("amd64") || osArch.startsWith("x86_64")) {
        return "x86_64";
    } else if (osArch.startsWith("arm64")) {
        return "arm64";
    } else if (osArch.startsWith("arm")) {
        return "arm";
    } else if ("ppc" == osArch || "powerpc" == osArch) {
        return "ppc";
    } else if (osArch.startsWith("ppc")) {
        return "ppc_64";
    } else if (osArch.startsWith("sparc")) {
        return "sparc";
    } else if (osArch.startsWith("mips64")) {
        return "mips64";
    } else if (osArch.startsWith("mips")) {
        return "mips";
    } else if (osArch.contains("risc")) {
        return "risc";
    }
    return "unknown";
}


configurations {
    jocl
    cuda
}

dependencies {
    def classifier = getOsString()+'-'+getArchString()
    compile (group: 'org.jcuda', name: 'jcuda', version: '0.9.0d',){
      transitive=false
    }
    compile (group: 'org.jcuda', name: 'jcufft', version: '0.9.0d',){
      transitive=false
    }
    compile group: 'org.jcuda', name: 'jcuda-natives', classifier: classifier, version: '0.9.0d'
    compile group: 'org.jcuda', name: 'jcufft-natives', classifier: classifier, version: '0.9.0d'
    implementation 'nl.junglecomputing.cashmere:cashmere:0.4'
    jocl 'org.jocl:jocl:2.0.4'
}

repositories {
    mavenLocal()
    mavenCentral()
}

jar.dependsOn(':fft:buildNative')
jar.dependsOn(':readjpg:buildNative')

jar.dependsOn(':clFFT:buildNative')
jar.dependsOn(':libjpeg-turbo:buildNative')

jar {
    def suffix = "-csicn-${version}.so"
    into("lib") {
	from("${project(':libjpeg-turbo').buildDir}/libjpeg-turbo-1.5.2/.libs") {
    	    include 'libjpeg.so'
    	    rename 'libjpeg.so', "libjpeg${suffix}"
	}
	from("${project(':readjpg').buildDir}") {
    	    include 'libreadjpg.so'
    	    rename 'libreadjpg.so', "libreadjpg${suffix}"
	}
	from("${project(':fft').buildDir}") {
    	    include 'libfft.so'
    	    rename 'libfft.so', "libfft${suffix}"
	}
    	from("${project(':clFFT').buildDir}/install/lib64") {
    	    include 'libclFFT.so'
	    rename 'libclFFT.so', "libclFFT${suffix}"
    	}
    }
}

task copyJOCL(type:Copy) {
    def dir = 'lib'
    def file = 'libJOCL_2_0_4-linux-x86_64.so'
    def fullpath = "$dir/$file"
    from({ zipTree(configurations.jocl.singleFile) }) {
        include fullpath
    }
    eachFile { fcd ->
	println fcd.path
	fcd.path = fcd.path.replaceAll(~/lib\/(.*)/, '$1')
	println fcd.path
    }
    into project(':fft').buildDir
}

void createTask(String name, String input, String outputDir, String dest) {
   task ("javah" + name, type:Exec) {
     dependsOn classes
     def classpath = configurations.runtimeClasspath + sourceSets.main.output.classesDirs
     def classpathString = classpath.join(":")
     commandLine "javac", "-d", project.buildDir, "-h", outputDir, "-classpath", classpathString, input
     inputs.files file(input)
   }
   task ("gen" + name + "Header", type: Copy) {
     dependsOn("javah" + name)
     from outputDir
     into outputDir
     include 'nl_junglecomputing_common_source_identification*.h'
     rename("nl_junglecomputing_common_source_identification.*.h", "$dest")
     outputs.files file(outputDir + "/$dest")
   }
}

createTask("FFT", "src/main/java/nl/junglecomputing/common_source_identification/mc/opencl/FFT.java", "fft/build/include", "fft.h")
    
createTask("ReadJPG", "src/main/java/nl/junglecomputing/common_source_identification/cpu/ReadJPG.java", "readjpg/build/include", "readjpg.h")

allprojects {
    task cleanNative(type: Delete, group: "Build native code", description: "Deletes the build directory") {
	destroyables.register(fileTree(project.buildDir))
	delete project.buildDir
    }
}

publishing {
    publications {
	mavenJava(MavenPublication) {
	    from components.java
	    artifact sourcesJar {
		classifier "sources"
	    }
	    groupId 'nl.junglecomputing.cashmere'
	    artifactId 'common-source-identification-cashmere-native'
	    version version

	    pom.withXml {
		def root = asNode()
                root.appendNode('url', 'https://github.com/JungleComputing/common-source-identification-cashmere-native.git')
                root.children().last() + pomConfig
	    }
	}
    }
}

bintray {
    user = System.getenv('BINTRAY_NAME')
    key = System.getenv('BINTRAY_APIKEY')
    publications = ['mavenJava']
    pkg {
	repo = 'JungleComputing-Cashmere'
	name = 'common-source-identification-cashmere-native'
	userOrg = "$user"
	vcsUrl = 'https://github.com/JungleComputing/common-source-identification-cashmere-native.git'
	licenses = ['Apache-2.0']
    }
}
