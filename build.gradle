plugins {
    id 'java-library'
    id 'maven'
    id 'signing'
}

version = '1.2'
group = 'nl.junglecomputing.cashmere'
archivesBaseName = 'common-source-identification-cashmere-native'

task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

javadoc.failOnError = false
javadoc.options.memberLevel = JavadocMemberLevel.PUBLIC
javadoc.options.links "https://JungleComputing.github.io/Constellation"

task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}

artifacts {
    archives sourcesJar
    archives javadocJar
}

def static getOsString() {
    String vendor = System.getProperty("java.vendor");
    if ("The Android Project" == vendor) {
        return "android";
    } else {
        String osName = System.getProperty("os.name");
        osName = osName.toLowerCase(Locale.ENGLISH);
        if (osName.startsWith("windows")) {
            return "windows";
        } else if (osName.startsWith("mac os")) {
            return "apple";
        } else if (osName.startsWith("linux")) {
            return "linux";
        } else if (osName.startsWith("sun")) {
            return "sun"
        }
        return "unknown"
    }
}

def static getArchString() {
    String osArch = System.getProperty("os.arch");
    osArch = osArch.toLowerCase(Locale.ENGLISH);
    if ("i386" == osArch || "x86" == osArch || "i686" == osArch) {
        return "x86";
    } else if (osArch.startsWith("amd64") || osArch.startsWith("x86_64")) {
        return "x86_64";
    } else if (osArch.startsWith("arm64")) {
        return "arm64";
    } else if (osArch.startsWith("arm")) {
        return "arm";
    } else if ("ppc" == osArch || "powerpc" == osArch) {
        return "ppc";
    } else if (osArch.startsWith("ppc")) {
        return "ppc_64";
    } else if (osArch.startsWith("sparc")) {
        return "sparc";
    } else if (osArch.startsWith("mips64")) {
        return "mips64";
    } else if (osArch.startsWith("mips")) {
        return "mips";
    } else if (osArch.contains("risc")) {
        return "risc";
    }
    return "unknown";
}


configurations {
    jocl
    cuda
}

// Note: if you change the JOCL version number, also do so in the copyJOCL task.
dependencies {
    def classifier = getOsString()+'-'+getArchString()
    compile (group: 'org.jcuda', name: 'jcuda', version: '0.9.0d',){
      transitive=false
    }
    compile (group: 'org.jcuda', name: 'jcufft', version: '0.9.0d',){
      transitive=false
    }
    compile group: 'org.jcuda', name: 'jcuda-natives', classifier: classifier, version: '0.9.0d'
    compile group: 'org.jcuda', name: 'jcufft-natives', classifier: classifier, version: '0.9.0d'
    implementation 'nl.junglecomputing.cashmere:cashmere:0.4'
    jocl 'org.jocl:jocl:2.0.4'
}

repositories {
    mavenLocal()
    mavenCentral()
}

jar.dependsOn(':fft:buildNative')
jar.dependsOn(':readjpg:buildNative')

jar.dependsOn(':clFFT:buildNative')
jar.dependsOn(':libjpeg-turbo:buildNative')

jar {
    def suffix = "-csicn-${version}.so"
    into("lib") {
	from("${project(':libjpeg-turbo').buildDir}/libjpeg-turbo-1.5.2/.libs") {
    	    include 'libjpeg.so'
    	    rename 'libjpeg.so', "libjpeg${suffix}"
	}
	from("${project(':readjpg').buildDir}") {
    	    include 'libreadjpg.so'
    	    rename 'libreadjpg.so', "libreadjpg${suffix}"
	}
	from("${project(':fft').buildDir}") {
    	    include 'libfft.so'
    	    rename 'libfft.so', "libfft${suffix}"
	}
    	from("${project(':clFFT').buildDir}/install/lib64") {
    	    include 'libclFFT.so'
	    rename 'libclFFT.so', "libclFFT${suffix}"
    	}
    }
}

task copyJOCL(type:Copy) {
    def dir = 'lib'
    def file = 'libJOCL_2_0_4-linux-x86_64.so'
    def fullpath = "$dir/$file"
    from({ zipTree(configurations.jocl.singleFile) }) {
        include fullpath
    }
    eachFile { fcd ->
	println fcd.path
	fcd.path = fcd.path.replaceAll(~/lib\/(.*)/, '$1')
	println fcd.path
    }
    into project(':fft').buildDir
}

void createTask(String name, String input, String outputDir, String dest) {
   task ("javah" + name, type:Exec) {
     dependsOn classes
     def classpath = configurations.runtimeClasspath + sourceSets.main.output.classesDirs
     def classpathString = classpath.join(":")
     commandLine "javac", "-d", project.buildDir, "-h", outputDir, "-classpath", classpathString, input
     inputs.files file(input)
   }
   task ("gen" + name + "Header", type: Copy) {
     dependsOn("javah" + name)
     from outputDir
     into outputDir
     include 'nl_junglecomputing_common_source_identification*.h'
     rename("nl_junglecomputing_common_source_identification.*.h", "$dest")
     outputs.files file(outputDir + "/$dest")
   }
}

createTask("FFT", "src/main/java/nl/junglecomputing/common_source_identification/mc/opencl/FFT.java", "fft/build/include", "fft.h")
    
createTask("ReadJPG", "src/main/java/nl/junglecomputing/common_source_identification/cpu/ReadJPG.java", "readjpg/build/include", "readjpg.h")

allprojects {
    task cleanNative(type: Delete, group: "Build native code", description: "Deletes the build directory") {
	destroyables.register(fileTree(project.buildDir))
	delete project.buildDir
    }
}

uploadArchives {
  repositories {
    mavenDeployer {
      beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }

      repository(url: "https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/") {
        authentication(userName: ossrhUsername, password: ossrhPassword)
      }

      // repository(url: "file://${System.properties['user.home']}/.m2/repository") {
      // }

      signing {
	sign configurations.archives
      }

      snapshotRepository(url: "https://s01.oss.sonatype.org/content/repositories/snapshots/") {
        authentication(userName: ossrhUsername, password: ossrhPassword)
      }

      pom.project {

        name 'Common-source-identification-cashmere-native'
        packaging 'jar'
        description 'Common-source-identification-cashmere-native is a support library for the common-source-identification-cashmere application; it interfaces to the native libraries to decode JPEG images and OpenCL FFT.'

        url 'https://github.com/junglecomputing/common-source-identification-cashmere-native'

        scm {
          connection 'scm:git:git://github.com/junglecomputing/common-source-identification-cashmere-native.git'
          developerConnection 'scm:git:ssh://github.com:junglecomputing/common-source-identification-cashmere-native.git'
          url 'https://github.com/junglecomputing/common-source-identification-cashmere-native/tree/master'
        }

        licenses {
          license {
            name 'The Apache License, Version 2.0'
            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
          }
        }

        developers {
          developer {
            name = 'Pieter Hijma'
            organization = 'Vrije Universiteit Amsterdam'
            url = 'https://github.com/pieterhijma'
          }
          developer {
            name = 'Ceriel Jacobs'
            organization = 'Vrije Universiteit Amsterdam'
            url = 'https://github.com/CerielJacobs'
          }
        }
      }
    }
  }
}

